package com.volunteerhub.backend.service.impl;

import com.volunteerhub.backend.dto.EventCreateRequest;
import com.volunteerhub.backend.dto.EventUpdateRequest;
import com.volunteerhub.backend.model.Event;
import com.volunteerhub.backend.model.User;
import com.volunteerhub.backend.repository.EventRepository;
import com.volunteerhub.backend.repository.UserRepository;
import com.volunteerhub.backend.service.EventService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class EventServiceImpl implements EventService {

    private final EventRepository eventRepository;
    private final UserRepository userRepository; // optional: to set createdBy

    public EventServiceImpl(EventRepository eventRepository, UserRepository userRepository) {
        this.eventRepository = eventRepository;
        this.userRepository = userRepository;
    }

    private EventDto toDto(Event e) {
        EventDto d = new EventDto();
        d.setId(e.getId());
        d.setTitle(e.getTitle());
        d.setDescription(e.getDescription());
        d.setCategory(e.getCategory());
        d.setLocation(e.getLocation());
        d.setStartTime(e.getStartTime());
        d.setEndTime(e.getEndTime());
        d.setStatus(e.getStatus());
        if (e.getCreatedBy() != null) d.setCreatedById(e.getCreatedBy().getId());
        return d;
    }

    @Override
    public List<EventDto> findAll() {
        return eventRepository.findAll().stream().map(this::toDto).collect(Collectors.toList());
    }

    @Override
    public Optional<EventDto> findById(Long id) {
        return eventRepository.findById(id).map(this::toDto);
    }

    @Override
    @Transactional
    public EventDto create(EventCreateRequest req) {
        // basic business validation
        if (req.getEndTime().isBefore(req.getStartTime())) {
            throw new IllegalArgumentException("End time must be after start time");
        }
        Event e = new Event();
        e.setTitle(req.getTitle());
        e.setDescription(req.getDescription());
        e.setCategory(req.getCategory());
        e.setLocation(req.getLocation());
        e.setStartTime(req.getStartTime());
        e.setEndTime(req.getEndTime());
        e.setStatus("PENDING"); // newly created events require approval
        // optionally set createdBy if provided in future
        eventRepository.save(e);
        return toDto(e);
    }

    @Override
    @Transactional
    public EventDto update(Long id, EventUpdateRequest req) {
        Event e = eventRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Event not found with id " + id));
        if (req.getEndTime().isBefore(req.getStartTime())) {
            throw new IllegalArgumentException("End time must be after start time");
        }
        e.setTitle(req.getTitle());
        e.setDescription(req.getDescription());
        e.setCategory(req.getCategory());
        e.setLocation(req.getLocation());
        e.setStartTime(req.getStartTime());
        e.setEndTime(req.getEndTime());
        if (req.getStatus() != null) e.setStatus(req.getStatus());
        eventRepository.save(e);
        return toDto(e);
    }

    @Override
    @Transactional
    public void delete(Long id) {
        Event e = eventRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Event not found with id " + id));
        eventRepository.delete(e);
    }

    @Override
    @Transactional
    public EventDto createWithUser(EventCreateRequest req, Long userId) {
        if (req.getEndTime().isBefore(req.getStartTime())) {
            throw new IllegalArgumentException("End time must be after start time");
        }
        Event e = new Event();
        e.setTitle(req.getTitle());
        e.setDescription(req.getDescription());
        e.setCategory(req.getCategory());
        e.setLocation(req.getLocation());
        e.setStartTime(req.getStartTime());
        e.setEndTime(req.getEndTime());
        e.setStatus("PENDING");
        if (userId != null) {
            User u = userRepository.findById(userId).orElse(null);
            e.setCreatedBy(u);
        }
        eventRepository.save(e);
        return toDto(e);
    }

}
